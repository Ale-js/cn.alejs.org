<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ale.js</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://cn.alejs.org/"/>
  <updated>2019-01-10T12:28:32.165Z</updated>
  <id>http://cn.alejs.org/</id>
  
  <author>
    <name>Bill Dong</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Watch</title>
    <link href="http://cn.alejs.org/guide/v1/ComponentWatch/"/>
    <id>http://cn.alejs.org/guide/v1/ComponentWatch/</id>
    <published>2019-01-10T12:18:24.773Z</published>
    <updated>2019-01-10T12:28:32.165Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Watch"><a href="#Watch" class="headerlink" title="Watch"></a>Watch<div class="v100-add"></div></h1><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p><code>Watch</code> 参数严格来说是一个各位开发者（尤其是插件开发者）都应该遵守的规范。</p><p>它用来和插件执行交互行为。也就是说，插件可以任意地调用存在在 <code>Watch</code> 参数里的任何信息。</p><h4 id="插件使用者"><a href="#插件使用者" class="headerlink" title="插件使用者"></a>插件使用者</h4><p>你只需要在定义组件时添加一个名叫 <code>watch</code> 的参数即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Ale(&quot;test&quot;, &#123;</span><br><span class="line">    /* ... */</span><br><span class="line">    watch: &#123;</span><br><span class="line">        /* 这里添加需要和插件交互的信息 */</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>具体 <code>watch</code> 参数里需要添加什么信息，请查看所用插件的教程文档。</p><h4 id="插件开发者"><a href="#插件开发者" class="headerlink" title="插件开发者"></a>插件开发者</h4><p>如果你没有看过 <a href="/guide/v1/plugin/">插件</a> 这篇教程，请先访问此教程。</p><p><br></p><p>当你在注入任何组件时，通过返回的 ale组件对象 内部的 <code>watch</code> 属性可以获取到该组件的 <code>watch</code> 属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ale.plugin.inject(function(obj)&#123;</span><br><span class="line">    /* obj是被注册组件渲染时的 ale组件对象 */</span><br><span class="line">    console.log(obj.watch);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Watch&quot;&gt;&lt;a href=&quot;#Watch&quot; class=&quot;headerlink&quot; title=&quot;Watch&quot;&gt;&lt;/a&gt;Watch&lt;div class=&quot;v100-add&quot;&gt;&lt;/div&gt;&lt;/h1&gt;&lt;h3 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;
      
    
    </summary>
    
      <category term="v1" scheme="http://cn.alejs.org/categories/v1/"/>
    
    
  </entry>
  
  <entry>
    <title>数据类型判定</title>
    <link href="http://cn.alejs.org/guide/v1/ComponentDataType/"/>
    <id>http://cn.alejs.org/guide/v1/ComponentDataType/</id>
    <published>2019-01-10T11:47:06.680Z</published>
    <updated>2019-01-11T01:38:40.081Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据类型判定"><a href="#数据类型判定" class="headerlink" title="数据类型判定"></a>数据类型判定<div class="v100-add"></div></h1><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>我们可以使用一个 <code>dataType</code> 属性来极其方便地让 Ale.js 自动判断数据类型是否准确：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Ale(<span class="string">"test"</span>, &#123;</span><br><span class="line">    template: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.data.key + <span class="keyword">this</span>.staticData.val;</span><br><span class="line">    &#125;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        key: <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    staticData: &#123;</span><br><span class="line">        val: <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    dataType: &#123;</span><br><span class="line">        <span class="comment">/* 这里添加dataType */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>dataType 内部需要设置一个 <code>data</code> 或 <code>staticData</code> 来指定要在哪种类型的数据里做判定：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dataType: &#123;</span><br><span class="line">    data: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    staticData: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如这样，我们只接收数字类型的参数：【如果为构造函数类型，那么 ale 将会使用 <code>instanceOf</code> 关键字来判断】</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dataType: &#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        key: <span class="built_in">Number</span></span><br><span class="line">    &#125;,</span><br><span class="line">    staticData: &#123;</span><br><span class="line">        val: <span class="built_in">Number</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或：【如果为字符串类型，那么 ale 将会使用 <code>typeof</code> 关键字来判断】</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dataType: &#123;</span><br><span class="line">    data: &#123;</span><br><span class="line">        key: <span class="string">"number"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    staticData: &#123;</span><br><span class="line">        val: <span class="string">"number"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class="demo" id="app"></p><script src="../../../../js/Ale.v1.min.js"></script><script>Ale("test", {    template: function(){        return "请更改 app.data.key 的值！然后在控制台中查看是否会报错";    },    data: {        key: 1    },    staticData: {        val: 0    },    dataType: {        data: {            key: "number"        },        staticData: {            val: "number"        }    }})var app = Ale.render("test", {    el: "#app"})</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数据类型判定&quot;&gt;&lt;a href=&quot;#数据类型判定&quot; class=&quot;headerlink&quot; title=&quot;数据类型判定&quot;&gt;&lt;/a&gt;数据类型判定&lt;div class=&quot;v100-add&quot;&gt;&lt;/div&gt;&lt;/h1&gt;&lt;h3 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; cla
      
    
    </summary>
    
      <category term="v1" scheme="http://cn.alejs.org/categories/v1/"/>
    
    
  </entry>
  
  <entry>
    <title>静态Data</title>
    <link href="http://cn.alejs.org/guide/v1/ComponentStaticData/"/>
    <id>http://cn.alejs.org/guide/v1/ComponentStaticData/</id>
    <published>2019-01-10T07:03:16.093Z</published>
    <updated>2019-01-10T07:13:18.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="静态-Data"><a href="#静态-Data" class="headerlink" title="静态 Data"></a>静态 Data<div class="v100-add"></div></h1><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>在 <a href="/guide/v1/ComponentData/">Data</a> 文章中，你已经学习了 <code>Data</code> 属性。如果你还没有学习，请先学完 Data。</p><h4 id="详细区别"><a href="#详细区别" class="headerlink" title="详细区别"></a>详细区别</h4><p><code>Data</code> 和 <code>Static Data</code> 的最重要的一个区别就是 - 静态数据在更新时视图不会刷新【请在控制台中输入 <code>app.staticData.i = &quot;new value&quot;</code>，查看一下下方示例是否会更新吧！】：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Ale(<span class="string">"test"</span>, &#123;</span><br><span class="line">    template: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"数据 i 在视图上的值为："</span> + <span class="keyword">this</span>.staticData.i;</span><br><span class="line">    &#125;,</span><br><span class="line">    staticData: &#123;</span><br><span class="line">        i: <span class="string">"Hello"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><div class="demo" id="app"></div><h4 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h4><p>同样的，静态数据也支持函数类型：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">staticData: function()&#123;</span><br><span class="line">    /* 需要使用 return 返回 */</span><br><span class="line">    return &#123;</span><br><span class="line">        i: &quot;Hello&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script src="../../../../js/Ale.v1.min.js"></script><script>Ale("test", {    template: function(){        return "数据 i 在视图上的值为：" + this.staticData.i;    },    staticData: {        i: "Hello"    }})var app = Ale.render("test", {    el: "#app"})</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;静态-Data&quot;&gt;&lt;a href=&quot;#静态-Data&quot; class=&quot;headerlink&quot; title=&quot;静态 Data&quot;&gt;&lt;/a&gt;静态 Data&lt;div class=&quot;v100-add&quot;&gt;&lt;/div&gt;&lt;/h1&gt;&lt;h3 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot;
      
    
    </summary>
    
      <category term="v1" scheme="http://cn.alejs.org/categories/v1/"/>
    
    
  </entry>
  
  <entry>
    <title>其他函数</title>
    <link href="http://cn.alejs.org/guide/v1/other/"/>
    <id>http://cn.alejs.org/guide/v1/other/</id>
    <published>2019-01-10T06:35:57.749Z</published>
    <updated>2019-01-11T01:59:26.025Z</updated>
    
    <content type="html"><![CDATA[<h1 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h1><h4 id="isHasThisComponent"><a href="#isHasThisComponent" class="headerlink" title="isHasThisComponent"></a>isHasThisComponent<div class="v100-add"></div></h4><p><code>Ale.isHasThisComponent</code> 函数用来获取一个组件是否被全局注册了（返回bool值）【接收一个参数，为组件名称】：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Ale(&quot;test&quot;, &#123;</span><br><span class="line">    template: function()&#123;</span><br><span class="line">        return this.data.isReg;</span><br><span class="line">    &#125;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        isReg: false</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">var app = Ale.render(&quot;test&quot;, &#123;</span><br><span class="line">    el: &quot;#app&quot;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.data.isReg = Ale.isHasThisComponent(&quot;test&quot;);</span><br></pre></td></tr></table></figure><div class="demo" id="app"></div><script src="../../../../js/Ale.v1.min.js"></script><script>Ale("test", {    template: function(){        return this.data.isReg;    },    data: {        isReg: false    }})var app = Ale.render("test", {    el: "#app"})app.data.isReg = Ale.isHasThisComponent("test");</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;其他函数&quot;&gt;&lt;a href=&quot;#其他函数&quot; class=&quot;headerlink&quot; title=&quot;其他函数&quot;&gt;&lt;/a&gt;其他函数&lt;/h1&gt;&lt;h4 id=&quot;isHasThisComponent&quot;&gt;&lt;a href=&quot;#isHasThisComponent&quot; class=&quot;
      
    
    </summary>
    
      <category term="v1" scheme="http://cn.alejs.org/categories/v1/"/>
    
    
  </entry>
  
  <entry>
    <title>代理</title>
    <link href="http://cn.alejs.org/guide/v1/ComponentProxy/"/>
    <id>http://cn.alejs.org/guide/v1/ComponentProxy/</id>
    <published>2019-01-10T01:59:21.384Z</published>
    <updated>2019-01-11T07:12:39.306Z</updated>
    
    <content type="html"><![CDATA[<h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理<div class="v100-add"></div></h1><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>在 1.0.0 中，我们废除了 debug 参数，增加了一个功能类似的 <code>proxy</code> 参数，只不过使用方式略有不同。</p><p>其中，proxy参数里的函数都将会自动绑定动态渲染的 <code>ale组件对象</code>，请使用一个参数访问：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">proxy: &#123;</span><br><span class="line">    setter: <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(obj); <span class="comment">//渲染完成后的 ale组件对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>proxy参数支持 <code>setter</code> 和 <code>getter</code> 函数，用来分别代理数据的设置和获取。你可以在组件定义时添加 <code>proxy</code>，也可以在渲染时动态添加。</p><h4 id="setter"><a href="#setter" class="headerlink" title="setter"></a>setter</h4><p>setter 参数需要为一个函数，同时需要接收一个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setter: <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>obj</code> 参数内部有以下几个键值：</p><ul><li>type【数据的类型。normal代表普通数据，static代表静态数据】</li><li>key【数据的名称】</li><li>val【新设置的值】</li><li>preventUpdating【函数，调用即阻止组件的视图更新，但是不阻止组件数据值的更新】</li></ul><p id="app" class="demo"></p><p>同时，你需要使用 <code>return</code> 关键字返回设置的新值，否则组件数据值将被更新为 <code>undefined</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">setter: <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj.val;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 或者你也可以返回你自行设置的值</span></span><br><span class="line"><span class="comment">        return "就不让你更新数据！";</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，你也可以使用 <code>preventUpdating</code> 函数来阻止组件的视图更新，但是不能阻止组件数据值的更新（通过return可以阻止）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setter: function(obj)&#123;</span><br><span class="line">    obj.preventUpdating();</span><br><span class="line">    return obj.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class="demo" id="app2"></p><h4 id="getter"><a href="#getter" class="headerlink" title="getter"></a>getter</h4><p>同样的，getter 参数需要为一个函数，同时也需要接收一个参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getter: <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>obj</code> 参数内部也有以下几个键值：</p><ul><li>type【数据的类型。normal代表普通数据，static代表静态数据】</li><li>key【数据的名称】</li><li>val【获取的值】</li><li>preventUpdating【函数，调用即阻止组件的视图更新，但是不阻止组件数据值的更新】<span style="color: red">【无效！因为getter不会造成视图更新！】</span></li></ul><script src="../../../../js/Ale.v1.min.js"></script><script>Ale('test', {    template: "重新设置 app.data.i 的值，你可以在控制台中看到 obj",    proxy: {        setter: function(obj){            console.log(obj);        }    },    data: {        i: 0    }})var app = Ale.render("test", {    el: "#app"})Ale('test2', {    template: function(){        return "重新设置 app2.data.i 的值，只有 app2.data.i 的值会更新，视图不会更新<br>app2.data.i 在视图上的值为：" + this.data.i;    },    proxy: {        setter: function(obj){            obj.preventUpdating();            return obj.val;        }    },    data: {        i: 0    }})var app2 = Ale.render("test2", {    el: "#app2"})</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;代理&quot;&gt;&lt;a href=&quot;#代理&quot; class=&quot;headerlink&quot; title=&quot;代理&quot;&gt;&lt;/a&gt;代理&lt;div class=&quot;v100-add&quot;&gt;&lt;/div&gt;&lt;/h1&gt;&lt;h3 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="v1" scheme="http://cn.alejs.org/categories/v1/"/>
    
    
  </entry>
  
  <entry>
    <title>异步队列</title>
    <link href="http://cn.alejs.org/guide/v1/nextTick/"/>
    <id>http://cn.alejs.org/guide/v1/nextTick/</id>
    <published>2019-01-10T01:25:35.121Z</published>
    <updated>2019-01-10T01:52:51.179Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异步队列"><a href="#异步队列" class="headerlink" title="异步队列"></a>异步队列<p class="v100-add"></p></h1><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>在 1.0.0 版本及以后，我们允许你使用<code>异步队列</code>更新DOM，这意味着更高的性能。</p><p>例如我们有一个需要循环更新的组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Ale(<span class="string">"test"</span>, &#123;</span><br><span class="line">    template: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.data.i;</span><br><span class="line">    &#125;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        i: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = Ale.render(<span class="string">"test"</span>, &#123;</span><br><span class="line">    el: <span class="string">"#app"</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 这里更新10000次 */</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">    app.data.i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上方实例的组件在 1.0-beta.1 版本中将会触发 <code>10000</code> 次的组件视图更新，而在 1.0.0+ 版本中，它只会更新一次，也就是最后的一次。</p><h4 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h4><p>但是这也就意味着我们无法使用 <code>innerHTML</code> 来获取组件里的内容，因为我们无法检测到它到底什么时候完成更新。</p><p><br></p><p>虽然 Ale 鼓励各位开发者沿着数据驱动的思维来思考。但是不得不承认的是，有的时候你确实需要获取组件的<code>innerHTML</code>。这时你就可以使用 <code>Ale.nextTick</code> 函数来给 Ale 的异步DOM更新队列添加一个回调函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ale.nextTick(function()&#123;</span><br><span class="line">    /* 这里添加一个回调函数作为参数 */</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这时你就可以获取组件的<code>innerHTML</code>了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ale.nextTick(function()&#123;</span><br><span class="line">    document.querySelector(&quot;#app&quot;).innerHTML;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h4><p>当你动态更新组件时，Ale 首先会检测是否异步更新队列已经被创建了。</p><ul><li><p>如果队列已经被创建了，那么 Ale 将会存储组件更新到一个队列中，并等待当前队列更新完成再更新。</p></li><li><p>如果队列没有被创建，那么 Ale 会直接创建一个更新队列以完成更新。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;异步队列&quot;&gt;&lt;a href=&quot;#异步队列&quot; class=&quot;headerlink&quot; title=&quot;异步队列&quot;&gt;&lt;/a&gt;异步队列&lt;p class=&quot;v100-add&quot;&gt;&lt;/p&gt;&lt;/h1&gt;&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="v1" scheme="http://cn.alejs.org/categories/v1/"/>
    
    
  </entry>
  
  <entry>
    <title>调试模式</title>
    <link href="http://cn.alejs.org/guide/v1/ComponentDebug/"/>
    <id>http://cn.alejs.org/guide/v1/ComponentDebug/</id>
    <published>2018-12-20T23:42:17.480Z</published>
    <updated>2019-01-10T07:25:40.587Z</updated>
    
    <content type="html"><![CDATA[<h1 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式<div class="v100-remove"></div></h1><h3 id="更新信息"><a href="#更新信息" class="headerlink" title="更新信息"></a>更新信息</h3><p>1.0.0 版本已经移除了 <code>debug</code> 配置。如果想实现类似效果，请使用 <a href="/guide/v1/ComponentProxy">proxy</a> 参数。</p><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>当你有一个庞大的前端系统时，如果没有办法监测数据的变化，那么调试就将变成噩梦。</p><p><code>debug</code> 参数的出现很好地解决了这个问题，你可以在组件<code>定义</code>或<code>渲染</code>时添加<code>debug</code>参数（渲染时的debug参数将会完全覆盖定义时设置的debug参数）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在定义时添加 */</span></span><br><span class="line">Ale(<span class="string">"test"</span>, &#123;</span><br><span class="line">    <span class="comment">/* ...... */</span></span><br><span class="line">    debug: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 或者在渲染时动态添加 */</span></span><br><span class="line">Ale.render(<span class="string">"test"</span>, &#123;</span><br><span class="line">    <span class="comment">/* ...... */</span></span><br><span class="line">    debug: &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>debug</code>参数内置有两个函数：<code>setter</code>和<code>getter</code>，分别监测组件数据的设置和获取 <strong>（其中，setter和getter各需要一个参数，用来接收值）</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Ale(<span class="string">"test"</span>, &#123;</span><br><span class="line">    <span class="comment">/* ...... */</span></span><br><span class="line">    debug: &#123;</span><br><span class="line">        setter: <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"你设置了我为："</span>+val);</span><br><span class="line">        &#125;,</span><br><span class="line">        getter: <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"你获取了我："</span>+val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p class="demo" id="app"></p><p>上方实例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Ale(<span class="string">"test"</span>, &#123;</span><br><span class="line">    template: <span class="string">"在控制台中获取或重设 app.data.data1 的值，然后查看控制台中的输出信息"</span>,</span><br><span class="line">    debug: &#123;</span><br><span class="line">        setter: <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"你设置了我为："</span>+val);</span><br><span class="line">        &#125;,</span><br><span class="line">        getter: <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"你获取了我："</span>+val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        data1: <span class="string">"Hello"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Ale.render(<span class="string">"test"</span>, &#123;</span><br><span class="line">    el: <span class="string">"#app"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><script src="../../../../js/Ale.min.js"></script><script>Ale("test", {    template: "在控制台中获取或重设 app.data.data1 的值，然后查看控制台中的输出信息",    debug: {        setter: function(val){            console.log("你设置了我为："+val);        },        getter: function(val){            console.log("你获取了我："+val);        }    },    data: {        data1: "Hello"    }})Ale.render("test", {    el: "#app"})</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;调试模式&quot;&gt;&lt;a href=&quot;#调试模式&quot; class=&quot;headerlink&quot; title=&quot;调试模式&quot;&gt;&lt;/a&gt;调试模式&lt;div class=&quot;v100-remove&quot;&gt;&lt;/div&gt;&lt;/h1&gt;&lt;h3 id=&quot;更新信息&quot;&gt;&lt;a href=&quot;#更新信息&quot; clas
      
    
    </summary>
    
      <category term="v1" scheme="http://cn.alejs.org/categories/v1/"/>
    
    
  </entry>
  
  <entry>
    <title>组件对象</title>
    <link href="http://cn.alejs.org/guide/v1/ComponentObj/"/>
    <id>http://cn.alejs.org/guide/v1/ComponentObj/</id>
    <published>2018-12-20T23:41:25.666Z</published>
    <updated>2019-01-11T00:54:55.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="组件对象"><a href="#组件对象" class="headerlink" title="组件对象"></a>组件对象</h1><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>当你每次 <code>render</code> 一个组件时，Ale 都会返回一个 <code>Ale组件对象</code>，你可以定义一个变量来接收它：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义一个变量接收 Ale组件对象 */</span></span><br><span class="line"><span class="keyword">var</span> app = Ale.render(<span class="string">"test"</span>, &#123;</span><br><span class="line">    <span class="comment">/* ...... */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p id="app" class="demo"></p><p>让我们点击上方实例，你将会看到它在控制台中输出了它自己的<code>Ale组件对象</code>。</p><h3 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h3><p>可是这造成了一个问题，如果我们的组件需要动态渲染，那我们怎么获取它的 <code>Ale组件对象</code> 呢？</p><p>很简单，只需要在支持函数的属性中使用 <code>this</code> 关键字即可获取 <strong>（1.0.0之前<code>template</code>属性自动绑定的是<code>this.data</code>，而在1.0.0版本及以后，template属性中使用<code>this</code>代指的是渲染完成后的 ale组件对象，也就是 <code>this</code>【但是你只可以访问ale组件对象的data、staticData、methods属性】）</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义一个组件 */</span></span><br><span class="line">Ale(<span class="string">"test"</span>, &#123;</span><br><span class="line">    life: &#123;</span><br><span class="line">        mounting: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>) <span class="comment">/* 这里this代指渲染完成之后的Ale组件对象 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在上方实例中，可能你还不了解<code>life</code>属性的作用，不过我们就是给你演示一下如何使用，具体细节请继续往下查看教程！</p><p>目前全部支持函数的属性：</p><ul><li>template <strong>（1.0.0之前<code>template</code>属性自动绑定的是<code>this.data</code>，而在1.0.0版本及以后，template属性中使用<code>this</code>代指的是渲染完成后的 ale组件对象，也就是 <code>this</code>【但是你只可以访问ale组件对象的data、staticData、methods属性】）</strong>：</li><li>life <strong>（life属性本身不支持函数，但是它内部的属性全部支持函数）</strong></li><li>debug <strong>（debug属性本身不支持函数，但是它内部的属性全部支持函数。<span style="color:red">不过注意，debug内部的函数<em>不会</em>绑定this</span>）</strong></li><li>proxy <strong>（proxy属性本身不支持函数，但是它内部的属性全部支持函数。）</strong></li></ul><script src="../../../../js/Ale.v1.min.js"></script><script>Ale("aleComObj", {    template: "<button onclick='console.log(app)'>点我在控制台中输出我的：Ale组件对象</button>"})var app = Ale.render("aleComObj", {    el: "#app"})</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;组件对象&quot;&gt;&lt;a href=&quot;#组件对象&quot; class=&quot;headerlink&quot; title=&quot;组件对象&quot;&gt;&lt;/a&gt;组件对象&lt;/h1&gt;&lt;h3 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h
      
    
    </summary>
    
      <category term="v1" scheme="http://cn.alejs.org/categories/v1/"/>
    
    
  </entry>
  
  <entry>
    <title>复合组件</title>
    <link href="http://cn.alejs.org/guide/v1/ComponentImport/"/>
    <id>http://cn.alejs.org/guide/v1/ComponentImport/</id>
    <published>2018-12-20T12:27:40.415Z</published>
    <updated>2019-01-10T06:55:30.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="复合组件"><a href="#复合组件" class="headerlink" title="复合组件"></a>复合组件</h1><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>Ale 允许你将任意的组件使用 <code>imports</code> 属性绑定到一起，绑定后的新组件将会成为一个 <code>复合组件</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义一个名为test-1的组件 */</span></span><br><span class="line">Ale(<span class="string">"test-1"</span>, &#123;</span><br><span class="line">    template: <span class="string">"Hello"</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义一个名为test的组件，然后引入test-1 */</span></span><br><span class="line">Ale(<span class="string">"test"</span>, &#123;</span><br><span class="line">    imports: [<span class="string">"test-1"</span>], <span class="comment">/* 这里需要为一个数组 */</span></span><br><span class="line">    template: <span class="string">"World"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>完成之后，<code>test</code>组件就变成了一个复合组件。</p><p>那么现在如果我们渲染<code>test</code>组件，那么它只会输出<code>World</code>，而不是我们需要的<code>HelloWorld</code>。这时我们可以在<code>test</code>组件的模板属性里使用自定义标签添加<code>test-1</code>组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ale(<span class="string">"test"</span>, &#123;</span><br><span class="line">    imports: [<span class="string">"test-1"</span>],</span><br><span class="line">    template: <span class="string">"&lt;test-1/&gt;World"</span> <span class="comment">/* 注意这里，我们使用&lt;test-1/&gt;这种格式渲染了test-1组件 */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>其中，我们使用<code>&lt;test-1/&gt;</code>这种格式渲染了test-1组件，那么需要注意的是，自定义标签只能为这种格式，<strong>一个空格都不能多加！</strong></p><p>现在让我们来渲染一下这个组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ale.render(<span class="string">"test"</span>, &#123;</span><br><span class="line">    el: <span class="string">"#app"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p class="demo" id="app"></p><p>已经正常工作了，对吧？其实你不只可以引入单组件，还可以引入复合组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义一个名为test-1的组件 */</span></span><br><span class="line">Ale(<span class="string">"test-1"</span>, &#123;</span><br><span class="line">    template: <span class="string">"Hello"</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义一个名为test-2的组件 */</span></span><br><span class="line">Ale(<span class="string">"test-2"</span>, &#123;</span><br><span class="line">    imports: [<span class="string">"test-1"</span>],</span><br><span class="line">    template: <span class="string">"&lt;test-1/&gt; "</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义一个名为test的组件，然后引入test-2 */</span></span><br><span class="line">Ale(<span class="string">"test"</span>, &#123;</span><br><span class="line">    imports: [<span class="string">"test-2"</span>],</span><br><span class="line">    template: <span class="string">"&lt;test-2/&gt;World"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p class="demo" id="app2"></p><h3 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h3><p>复合组件相比普通（单）组件：</p><ul><li>整个复合组件共用一个<code>data</code>。也就是说，复合组件之间没有层级关系，任何组件都可以操作另外的所有组件里的数据。<strong>（另外，按imports导入的先后顺序，同名的数据将会覆盖之前的同名数据）</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义一个名为test-1的组件 */</span></span><br><span class="line">Ale(<span class="string">"test-1"</span>, &#123;</span><br><span class="line">    template: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.data.h; <span class="comment">/* 这里访问了test组件的数据 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义一个名为test-2的组件 */</span></span><br><span class="line">Ale(<span class="string">"test-2"</span>, &#123;</span><br><span class="line">    imports: [<span class="string">"test-1"</span>],</span><br><span class="line">    template: <span class="string">"&lt;test-1/&gt; "</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义一个名为test的组件，然后引入test-2 */</span></span><br><span class="line">Ale(<span class="string">"test"</span>, &#123;</span><br><span class="line">    imports: [<span class="string">"test-2"</span>],</span><br><span class="line">    template: <span class="string">"&lt;test-2/&gt;World"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        h: <span class="string">"Hello"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p class="demo" id="app3"></p><ul><li><p>整个复合组件共用一个methods。</p></li><li><p>整个复合组件共用一个proxy。</p></li><li><p>整个复合组件共用一个life。</p></li></ul><h4 id="引入局部组件"><a href="#引入局部组件" class="headerlink" title="引入局部组件"></a>引入局部组件<div class="v100-add"></div></h4><p>如果你想引入局部组件，直接在 <code>imports</code> 属性里引用 <code>Ale局部组件生成对象</code> 即可。</p><p>同时你需要给局部组件增加一个 <code>name</code> 属性，否则 Ale 没有办法区分局部组件的名称【默认为unknown】：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义一个名为test-1的局部组件 */</span></span><br><span class="line"><span class="keyword">var</span> test1 = Ale(&#123;</span><br><span class="line">    template: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.data.h; <span class="comment">/* 这里访问了test组件的数据 */</span></span><br><span class="line">    &#125;,</span><br><span class="line">    name: <span class="string">"test1"</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义一个名为test-2的组件 */</span></span><br><span class="line"><span class="keyword">var</span> test2 = Ale(&#123;</span><br><span class="line">    imports: [test1],</span><br><span class="line">    template: <span class="string">"&lt;test1/&gt; "</span>,</span><br><span class="line">    name: <span class="string">"test2"</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 定义一个名为test的组件，然后引入test-2 */</span></span><br><span class="line"><span class="keyword">var</span> test = Ale(&#123;</span><br><span class="line">    imports: [test2],</span><br><span class="line">    template: <span class="string">"&lt;test2/&gt;World"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        h: <span class="string">"Hello"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">test.render(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p class="demo" id="app4"></p><script src="../../../../js/Ale.v1.min.js"></script><script>Ale("test-1", {    template: "Hello"})Ale("test", {    imports: ["test-1"],    template: "<test-1/>World"})Ale.render("test", {    el: "#app"})Ale("test-2", {    imports: ["test-1"],    template: "<test-1/> "})Ale("test-3", {    imports: ["test-2"],    template: "<test-2/>World"})Ale.render("test-3", {    el: "#app2"})Ale("test-4", {    template: function(){        return this.data.h;    }})Ale("test-5", {    imports: ["test-4"],    template: "<test-4/> "})Ale("test-6", {    imports: ["test-5"],    template: "<test-5/>World",    data: {        h: "Hello"    }})Ale.render("test-6", {    el: "#app3"})var test1 = Ale({    template: function(){        return this.data.h;    },    name: "test1"})var test2 = Ale({    imports: [test1],    template: "<test1/> ",    name: "test2"})var test = Ale({    imports: [test2],    template: "<test2/>World",    data: {        h: "Hello"    }})test.render({    el: "#app4"})</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;复合组件&quot;&gt;&lt;a href=&quot;#复合组件&quot; class=&quot;headerlink&quot; title=&quot;复合组件&quot;&gt;&lt;/a&gt;复合组件&lt;/h1&gt;&lt;h3 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h
      
    
    </summary>
    
      <category term="v1" scheme="http://cn.alejs.org/categories/v1/"/>
    
    
  </entry>
  
  <entry>
    <title>Method</title>
    <link href="http://cn.alejs.org/guide/v1/ComponentMethod/"/>
    <id>http://cn.alejs.org/guide/v1/ComponentMethod/</id>
    <published>2018-12-20T07:28:53.924Z</published>
    <updated>2019-01-10T11:41:24.386Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h1><h4 id="1-0-0更新内容："><a href="#1-0-0更新内容：" class="headerlink" title="1.0.0更新内容："></a>1.0.0更新内容：</h4><p>1.0.0 版本及以后，在 <code>methods</code> 参数里的任何函数里使用 <code>this</code> 可以代指渲染之后的 ale组件对象。</p><p><br></p><p>同时，在 1.0.0 版本及以后，你也可以在组件渲染时动态设置或覆盖 <code>methods</code> 属性。</p><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>让我们接着组件 <a href="/guide/v1/ComponentLife/">生命周期</a> 的教程来讲解，还是定时器的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Ale(<span class="string">"timer"</span>, &#123;</span><br><span class="line">    template: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;span&gt;Now Time: &lt;/span&gt;"</span> + <span class="keyword">this</span>.data.time</span><br><span class="line">    &#125;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        time: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString()</span><br><span class="line">    &#125;,</span><br><span class="line">    life: &#123;</span><br><span class="line">        mounting: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">/* 这里需要使用箭头函数，因为不会绑定 this */</span></span><br><span class="line">            <span class="keyword">this</span>.timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.data.time = <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString();</span><br><span class="line">            &#125;, <span class="number">1000</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        unmounting: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            clearInterval(<span class="keyword">this</span>.timer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Ale.render(<span class="string">"timer"</span>, &#123;</span><br><span class="line">    el: <span class="string">"#app"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p></p><p class="demo" id="app">&lt;/p</p><p>不知道你有没有注意到，我们的定时器直接添加在 <code>this</code> 上：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 注意这里，直接绑定到 Ale组件对象上(this) */</span></span><br><span class="line"><span class="keyword">this</span>.timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">this</span>.data.time = <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString();</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>可是，如果我们不小心，添加的函数与 <code>Ale组件对象</code> 里的内置函数重名了，那么将会有一些未知 BUG 出现。</p><p>这时，我们推荐你将函数添加到 <code>Ale组件对象</code> 里的内置属性 <code>methods</code> 上！</p><p>让我们修改一下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Ale(<span class="string">"timer"</span>, &#123;</span><br><span class="line">    template: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;span&gt;Now Time: &lt;/span&gt;"</span> + <span class="keyword">this</span>.data.time</span><br><span class="line">    &#125;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        time: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString()</span><br><span class="line">    &#125;,</span><br><span class="line">    life: &#123;</span><br><span class="line">        mounting: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">/* 注意这里，绑定methods上 */</span></span><br><span class="line">            <span class="keyword">this</span>.methods.timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.data.time = <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString();</span><br><span class="line">            &#125;, <span class="number">1000</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        unmounting: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            clearInterval(<span class="keyword">this</span>.methods.timer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>实例是可以正常执行的。</p><p>同时，你也可以在组件定义时设置 <code>methods</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Ale(<span class="string">"test"</span>, &#123;</span><br><span class="line">    template: <span class="string">"test"</span>,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        <span class="comment">/* 定义一个名为 testFn 的函数 */</span></span><br><span class="line">        testFn: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="string">"test!"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    life: &#123;</span><br><span class="line">        mounting: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">/* 动态调用它 */</span></span><br><span class="line">            <span class="keyword">this</span>.methods.testFn();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h3><p>同 <code>data</code> 属性一样，<code>methods</code> 属性也会自动绑定到组件的全部元素及子元素上，通过 <code>this.methods</code> 即可访问：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">template: <span class="string">"&lt;span onclick='this.methods.testFn()'&gt;Click me!&lt;/span&gt;"</span></span><br></pre></td></tr></table></figure><div class="demo" id="app2"></div><script src="../../../../js/Ale.v1.min.js"></script><script>Ale("timer", {    template: function(){        return "<span>Now Time: </span>" + this.data.time    },    data: {        time: new Date().toLocaleTimeString()    },    life: {        mounting: function(){            this.timer = setInterval(() => {                this.data.time = new Date().toLocaleTimeString();            }, 1000);        },        unmounting: function(){            clearInterval(this.timer);        }    }})Ale.render("timer", {    el: "#app"})Ale("test", {    template: "<span onclick='this.methods.testFn()'>Click me!</span>",    methods: {        testFn: function(){            alert("test!")        }    }})Ale.render("test", {    el: "#app2"})</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Method&quot;&gt;&lt;a href=&quot;#Method&quot; class=&quot;headerlink&quot; title=&quot;Method&quot;&gt;&lt;/a&gt;Method&lt;/h1&gt;&lt;h4 id=&quot;1-0-0更新内容：&quot;&gt;&lt;a href=&quot;#1-0-0更新内容：&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="v1" scheme="http://cn.alejs.org/categories/v1/"/>
    
    
  </entry>
  
  <entry>
    <title>深入响应式原理</title>
    <link href="http://cn.alejs.org/guide/v1/deepInRespond/"/>
    <id>http://cn.alejs.org/guide/v1/deepInRespond/</id>
    <published>2018-12-20T06:47:59.009Z</published>
    <updated>2019-01-05T01:49:46.665Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入响应式原理"><a href="#深入响应式原理" class="headerlink" title="深入响应式原理"></a>深入响应式原理</h1><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Ale 使用 ES5 全新的 <code>defineProperty</code> 属性给对象添加 setter 和 getter。同时 Object.defineProperty 是 ES5 中一个无法 shim 的特性，并不是语法糖，这也就是为什么 Ale 不支持 IE8 以及更低版本浏览器。</p><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>受现代 JavaScript 的限制 (而且 <code>Object.observe</code> 也已经被废弃)，Ale <strong>不能检测到对象属性的添加或删除</strong>。由于 Ale 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Ale 转换它，这样才能让它是响应的。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data.a = <span class="number">2</span>; <span class="comment">/* 响应式 */</span></span><br><span class="line"></span><br><span class="line">data.b = <span class="number">2</span>; <span class="comment">/* 非响应式 */</span></span><br></pre></td></tr></table></figure><p>所以当你设置数据时，<strong>必需</strong> 设置需要具有响应式效果数据的值，哪怕它只是一个空值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="string">''</span> <span class="comment">/* 这里需要设置为空 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="具体"><a href="#具体" class="headerlink" title="具体"></a>具体</h3><p>当你触发 setter（操作数据更新时），Ale 首先会更新这些数据，然后计算出更新后的全部属性结果，并循环更新。</p><p><br></p><p>其中，<code>template</code>属性比较特殊，当数据更新完成后，Ale 会调用 <code>diff</code> 算法的函数，并生成一个 <code>伪DOM结构体</code>，Ale的diff算法将会比较 <code>伪DOM结构</code> 和 <code>真实DOM结构</code> 的区别，并且只更新有差异的 DOM 元素。</p><p><br></p><p>另外，diff 对比只会在同级 DOM 中进行，一旦发生层级改变，Ale 将不会继续对比，而是直接更新整个层。这样可以有效地增加 diff 的对比性能，减少对比的时间。</p><p><br></p><p>还有一点，Ale 的 <code>diff</code> 算法只会对比元素的 <code>内容</code> \ <code>id</code> \ <code>class</code> \ <code>name</code> 属性是否相同，也就是说，当你动态更新例如 <code>onclick</code> 之类的属性，<code>diff</code> 算法是不会对比出差异的，而元素也就不会更新。这时你可以在元素更新时手动关闭 <code>diff</code> 算法，并在元素更新完成时开启即可！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入响应式原理&quot;&gt;&lt;a href=&quot;#深入响应式原理&quot; class=&quot;headerlink&quot; title=&quot;深入响应式原理&quot;&gt;&lt;/a&gt;深入响应式原理&lt;/h1&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简
      
    
    </summary>
    
      <category term="v1" scheme="http://cn.alejs.org/categories/v1/"/>
    
    
  </entry>
  
  <entry>
    <title>生命周期</title>
    <link href="http://cn.alejs.org/guide/v1/ComponentLife/"/>
    <id>http://cn.alejs.org/guide/v1/ComponentLife/</id>
    <published>2018-12-20T05:48:00.629Z</published>
    <updated>2019-01-11T02:50:44.530Z</updated>
    
    <content type="html"><![CDATA[<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>在 Ale 中，一个组件共有六种生命状态，分别对应着它们的同名生命周期函数：</p><ul><li>using（组件被使用时）</li><li>mounting（组件被插入真实 DOM 时）</li><li>unmounting（组件移出真实 DOM 时）</li><li>rendering（组件被渲染时）</li><li>updating（组件更新时）</li><li>destroy（组件被销毁时）</li><li>staticDataUpdating（静态数据更新时）<div class="v100-add"></div></li></ul><p>你可以在定义组件时添加一个名为 <code>life</code> 的属性，并在 <code>life</code> 属性里添加函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Ale(<span class="string">"test"</span>, &#123;</span><br><span class="line">    template: <span class="string">"test"</span>,</span><br><span class="line">    life: &#123;</span><br><span class="line">        <span class="comment">/* 这里添加life属性，需要为object */</span></span><br><span class="line">        <span class="comment">/* 添加using函数，当组件被使用时触发 */</span></span><br><span class="line">        using: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="string">"using!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p class="demo" id="app"><button onclick="Ale.render('test',{el: '#app'})">点我渲染 test 组件</button></p><h3 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h3><p>除了 using 函数，其他的函数都将自动绑定 Ale 组件对象。如果你需要更改 data，请使用 <code>this.data</code> 这种形式更改：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Ale(<span class="string">"test"</span>, &#123;</span><br><span class="line">    template: <span class="string">"test"</span>,</span><br><span class="line">    life: &#123;</span><br><span class="line">        <span class="comment">/* 这里添加life属性，需要为object */</span></span><br><span class="line">        <span class="comment">/* 添加rendering函数，当组件被渲染时触发 */</span></span><br><span class="line">        rendering: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.data); <span class="comment">/* 打印data */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="在线实例"><a href="#在线实例" class="headerlink" title="在线实例"></a>在线实例</h3><p>让我们来制作一个定时器，输出当前时间，每秒更新一次：<a href="https://jsfiddle.net/billdong/y5p327vq/2/" target="_blank" rel="noopener">在jsfiddle上查看</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Ale(<span class="string">"timer"</span>, &#123;</span><br><span class="line">    template: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Now Time: "</span> + <span class="keyword">this</span>.data.time</span><br><span class="line">    &#125;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        time: <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString()</span><br><span class="line">    &#125;,</span><br><span class="line">    life: &#123;</span><br><span class="line">        mounting: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="comment">/* 这里需要使用箭头函数，因为不会绑定 this */</span></span><br><span class="line">            <span class="keyword">this</span>.timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.data.time = <span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString();</span><br><span class="line">            &#125;, <span class="number">1000</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        unmounting: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            clearInterval(<span class="keyword">this</span>.timer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Ale.render(<span class="string">"timer"</span>, &#123;</span><br><span class="line">    el: <span class="string">"#app"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p class="demo" id="app2"></p><p>上方定时器不会应用 Ale 内置的 <code>diff</code> 算法，因为你需要将不需要更新的元素用 DOM 标签包裹起来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">template: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"&lt;span&gt;Now Time: &lt;/span&gt;"</span> + <span class="keyword">this</span>.data.time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p class="demo" id="app3"></p><p>现在你可以打开控制台，对比一下这两个实例 DOM 的刷新，你会发现这个实例的 <code>Now Time:</code> 并没有更新。</p><script src="../../../../js/Ale.v1.min.js"></script><script>Ale("test", {    template: "test",    life: {        using: function(){            alert("using!");        }    }})Ale("timer", {    template: function(){        return "Now Time: " + this.data.time    },    data: {        time: new Date().toLocaleTimeString()    },    life: {        mounting: function(){            this.timer = setInterval(() => {                this.data.time = new Date().toLocaleTimeString();            }, 1000);        },        unmounting: function(){            clearInterval(this.timer);        }    }})Ale.render("timer", {    el: "#app2"})Ale("timer2", {    template: function(){        return "<span>Now Time: </span>" + this.data.time    },    data: {        time: new Date().toLocaleTimeString()    },    life: {        mounting: function(){            this.timer = setInterval(() => {                this.data.time = new Date().toLocaleTimeString();            }, 1000);        },        unmounting: function(){            clearInterval(this.timer);        }    }})Ale.render("timer2", {    el: "#app3"})</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;生命周期&quot;&gt;&lt;a href=&quot;#生命周期&quot; class=&quot;headerlink&quot; title=&quot;生命周期&quot;&gt;&lt;/a&gt;生命周期&lt;/h1&gt;&lt;h3 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h
      
    
    </summary>
    
      <category term="v1" scheme="http://cn.alejs.org/categories/v1/"/>
    
    
  </entry>
  
  <entry>
    <title>Data</title>
    <link href="http://cn.alejs.org/guide/v1/ComponentData/"/>
    <id>http://cn.alejs.org/guide/v1/ComponentData/</id>
    <published>2018-12-20T02:33:09.313Z</published>
    <updated>2019-01-10T07:25:10.097Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h1><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>在 <a href="/guide/v1/ComponentFoundation/">组件基础</a> 文章中，相信你已经了解了一些基础的添加数据的方法。如果你还没有学习过这篇教程，请完成学习后再来吧！</p><p>在组件基础这篇教程里，你只学到了如何添加 <code>data</code>。那么，为什么要动态添加 <code>data</code> 呢？</p><p><br></p><p>其实很简单，因为模板是静态的，而数据是动态的。如果我们更改某一处数据，其实比更改模板简单得多！</p><p>例如我们先定义一个名为<code>com1</code>的组件，然后把它渲染出来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Ale(<span class="string">"com1"</span>, &#123;</span><br><span class="line">    template: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + <span class="keyword">this</span>.data.name;</span><br><span class="line">    &#125;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        name: <span class="string">"World"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Ale.render(<span class="string">"com1"</span>, &#123;</span><br><span class="line">    el: <span class="string">"#app"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>渲染结果如下：</p><p id="app" class="demo"></p><p>那么我们既然知道了可以动态修改数据，那么如何修改呢？</p><p><br></p><p>很简单，我们只需要将 <code>Ale.render</code> 函数返回的结果（其实就是 Ale 组件对象）存储到一个变量里：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = Ale.render(<span class="string">"com1"</span>, &#123;</span><br><span class="line">    el: <span class="string">"#app"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后再使用这个变量来操作 <code>data</code> 即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.data.name = <span class="string">"Ale.js"</span>; <span class="comment">/* 重新赋值 */</span></span><br></pre></td></tr></table></figure><p>现在让我们在控制台中输入 <code>app.data.name = &quot;Ale.js&quot;</code>，然后你将会看到下方实例动态更新：</p><p id="app2" class="demo"></p><p>同时，我们的数据将会自动绑定在组件内的全部元素上，使用 <code>this.data</code> 即可访问，例如我们来做个记录点击次数的组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义组件 */</span></span><br><span class="line">Ale(<span class="string">"counter"</span>, &#123;</span><br><span class="line">    template: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">/* 这里让 this.data.count 自增 */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"&lt;button onclick='this.data.count++'&gt;You clicked me "</span> + <span class="keyword">this</span>.data.count + <span class="string">" times."</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        count: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 渲染组件 */</span></span><br><span class="line">Ale.render(<span class="string">"counter"</span>, &#123;</span><br><span class="line">    el: <span class="string">"#app"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p class="demo" id="app3"></p><p>其实数据不光可以应用在模板上，也可以应用在任何支持函数的属性上。当然，每当你更新数据时，这些绑定数据的属性也会得到更新。</p><p>具体有哪些属性可以应用数据，请继续往下查看教程！</p><h3 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h3><h4 id="关于-Vue"><a href="#关于-Vue" class="headerlink" title="关于 Vue"></a>关于 Vue</h4><p>如果你了解过 Vue，你将会发现，使用 Vue 设置数据需要添加一个函数，然后使用 return 返回需要的数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">/* 这里添加 data */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vue 这么做是因为每次 JavaScript 引擎复制对象时，会连同对象的内存地址一块复制，这样会导致一个对象更新时另一个对象也会更新。这时如果我们使用函数每次返回一个对象，就而相当于每次新创建了一个内存地址不同的新对象，就不会有上述问题了。</p><p><br></p><p>可是这么做会导致你需要书写的代码量增多，而 Ale 使用深拷贝从对象根部进行扫描，并逐层创建一个全新的对象。这样做会造成一定的性能损耗（小数据量时忽略不计），但是同时也减少了你需要书写的代码量。</p><p><br></p><p>如果你需要多个组件共用一套数据，请尝试让一个组件在一次渲染时同时渲染多个元素，或使用 <a href="/guide/v1/ComponentImport">复合组件</a>。</p><h4 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h4><p>你也可以使用 <code>app.data</code> 这种格式设置组件的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.data = &#123;</span><br><span class="line">    count: 1,</span><br><span class="line">    key: &quot;val&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="提升性能"><a href="#提升性能" class="headerlink" title="提升性能"></a>提升性能<div class="v100-add"></div></h4><p>在 1.0.0 版本里（及以后），我们让单组件data支持函数类型，能够在极大数据量时显著增加性能（因为不需要深拷贝），不过如果在渲染时动态设置data，那么函数优化将没有任何作用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">/* 需要使用 return 返回 */</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        count: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><script src="../../../../js/Ale.v1.min.js"></script><script>Ale("com1", {    template: function(){        return "Hello " + this.data.name;    },    data: {        name: "World"    }})Ale.render("com1", {    el: "#app"})var app = Ale.render("com1", {    el: "#app2"})Ale("counter", {    template: function(){        return "<button onclick='this.data.count++'>You clicked me " + this.data.count + " times.";    },    data: {        count: 0    }})Ale.render("counter", {    el: "#app3"})</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Data&quot;&gt;&lt;a href=&quot;#Data&quot; class=&quot;headerlink&quot; title=&quot;Data&quot;&gt;&lt;/a&gt;Data&lt;/h1&gt;&lt;h3 id=&quot;开始&quot;&gt;&lt;a href=&quot;#开始&quot; class=&quot;headerlink&quot; title=&quot;开始&quot;&gt;&lt;/a&gt;开始&lt;/h
      
    
    </summary>
    
      <category term="v1" scheme="http://cn.alejs.org/categories/v1/"/>
    
    
  </entry>
  
  <entry>
    <title>插件</title>
    <link href="http://cn.alejs.org/guide/v1/plugin/"/>
    <id>http://cn.alejs.org/guide/v1/plugin/</id>
    <published>2018-12-20T02:21:16.555Z</published>
    <updated>2019-01-10T12:17:36.489Z</updated>
    
    <content type="html"><![CDATA[<h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><h3 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h3><p>我们需要使用 <code>Ale.use</code> 函数来加载一个插件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ale.use();</span><br></pre></td></tr></table></figure><p>其中，<code>Ale.use</code> 函数需要一个参数，来指定要加载的 Ale 插件对象。例如我们传入一个名为 <code>test</code> 的 Ale 插件对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ale.use(test);</span><br></pre></td></tr></table></figure><p><code>test</code> 其实就是一个变量。在下面的章节中，我们将会学习如何制作一个 Ale 插件对象。</p><h3 id="制作插件"><a href="#制作插件" class="headerlink" title="制作插件"></a>制作插件</h3><p>首先先让我们来定义一个<code>object</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义一个名为test的变量 */</span></span><br><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要想让 <code>test</code> 成为一个 Ale 插件对象，那么它至少要具备 <code>name</code> 和 <code>install</code> 属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = &#123;</span><br><span class="line">    name: <span class="string">"test"</span>, <span class="comment">/* 插件名称 */</span></span><br><span class="line">    install: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">/* 安装函数，当用户 use 插件时会调用 */</span></span><br><span class="line">        alert(<span class="string">"Hello!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以在 <code>install</code> 属性里给 Ale 对象的 <code>prototype</code> 属性添加函数或属性…</p><p>反正随便啦，安装函数支持任意的 JavaScript 代码！</p><h4 id="plugin对象"><a href="#plugin对象" class="headerlink" title="plugin对象"></a>plugin对象<div class="v100-add"></div></h4><p>通过 <code>Ale.plugin.函数名称</code> 这种格式来调用 plugin 内部的任何内容。</p><p>目前 plugin 对象内置的函数如下：</p><ul><li>inject() <strong>【inject函数需要一个参数，类型需要为function，用来向组件内部注入内容（每当组件被渲染时都会触发）】</strong></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Ale.plugin.inject(<span class="function"><span class="keyword">function</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    <span class="comment">/* 添加一个参数，obj是被注册组件渲染时的 ale组件对象 */</span></span><br><span class="line">    <span class="built_in">console</span>.log(obj);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><div id="app" class="demo"><button onclick="Ale.render('test', {el: '#app'})">点我渲染test组件，同时你可以在控制台中查看输出信息</button></div><h3 id="在线实例"><a href="#在线实例" class="headerlink" title="在线实例"></a>在线实例</h3><p>我们已经定义了一个名为 <code>test</code> 的 Ale 插件对象，现在让我们在控制台中输入 <code>Ale.use(test)</code> 来安装它吧！（安装时会输出 Hello! ）</p><script src="../../../../js/Ale.v1.min.js"></script><script>var test = {    name: "test",    install: function(){        alert("Hello!");    }}var test2 = {    name: "test2",    install: function(){        Ale.plugin.inject(function(obj){            console.log(obj);        })    }}Ale.use(test2);Ale("test", {    template: function(){        return "TEST"    }})</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;插件&quot;&gt;&lt;a href=&quot;#插件&quot; class=&quot;headerlink&quot; title=&quot;插件&quot;&gt;&lt;/a&gt;插件&lt;/h1&gt;&lt;h3 id=&quot;使用插件&quot;&gt;&lt;a href=&quot;#使用插件&quot; class=&quot;headerlink&quot; title=&quot;使用插件&quot;&gt;&lt;/a&gt;使用插件&lt;/h
      
    
    </summary>
    
      <category term="v1" scheme="http://cn.alejs.org/categories/v1/"/>
    
    
  </entry>
  
  <entry>
    <title>版本</title>
    <link href="http://cn.alejs.org/guide/v1/version/"/>
    <id>http://cn.alejs.org/guide/v1/version/</id>
    <published>2018-12-20T02:17:15.906Z</published>
    <updated>2019-01-10T01:17:59.921Z</updated>
    
    <content type="html"><![CDATA[<h1 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h1><h3 id="version-属性"><a href="#version-属性" class="headerlink" title="version 属性"></a>version 属性</h3><p>你可以通过以下这种方式获取 Ale 当前的版本信息：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ale.version</span><br></pre></td></tr></table></figure><p>当前官网包含的最高 Ale 的版本为：</p><p class="demo" id="app"></p><script src="../../../../js/Ale.v1.min.js"></script><script>Ale("com1", {    template: function(){        return this.data.version;    }});Ale.render("com1", {    el: "#app",    data: {        version: Ale.version    }})</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;版本&quot;&gt;&lt;a href=&quot;#版本&quot; class=&quot;headerlink&quot; title=&quot;版本&quot;&gt;&lt;/a&gt;版本&lt;/h1&gt;&lt;h3 id=&quot;version-属性&quot;&gt;&lt;a href=&quot;#version-属性&quot; class=&quot;headerlink&quot; title=&quot;versi
      
    
    </summary>
    
      <category term="v1" scheme="http://cn.alejs.org/categories/v1/"/>
    
    
  </entry>
  
  <entry>
    <title>过滤器</title>
    <link href="http://cn.alejs.org/guide/v1/filter/"/>
    <id>http://cn.alejs.org/guide/v1/filter/</id>
    <published>2018-12-20T01:38:57.764Z</published>
    <updated>2019-01-10T11:40:55.190Z</updated>
    
    <content type="html"><![CDATA[<h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h1><h3 id="filter-函数"><a href="#filter-函数" class="headerlink" title="filter 函数"></a>filter 函数</h3><p>Ale 函数内置了 <code>Ale.filter</code> 函数，在每次 DOM 更新时过滤敏感信息。</p><p>在 Ale 中，过滤器是一个队列。在你每次调用 <code>Ale.filter</code> 函数时，会自动往队列内插入过滤函数。你可以通过这种方式添加过滤器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* filter函数接收一个参数，你可以传入一个函数。但是这个函数必须要有一个参数，然后将过滤的结果用return返回 */</span></span><br><span class="line">Ale.filter(<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 过滤全部数字1 */</span></span><br><span class="line">    msg = msg.replace(<span class="regexp">/1/g</span>, <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">return</span> msg;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 或者你可以传入一个数组 */</span></span><br><span class="line">Ale.filter([<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 过滤全部数字1 */</span></span><br><span class="line">    msg = msg.replace(<span class="regexp">/1/g</span>, <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">return</span> msg;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 过滤全部数字2 */</span></span><br><span class="line">    msg = msg.replace(<span class="regexp">/2/g</span>, <span class="string">""</span>)</span><br><span class="line">    <span class="keyword">return</span> msg;</span><br><span class="line">&#125;])</span><br></pre></td></tr></table></figure><h3 id="在线实例"><a href="#在线实例" class="headerlink" title="在线实例"></a>在线实例</h3><p id="app" class="demo"></p><p>在上方实例中，我们添加了一个全局过滤器，它可以过滤掉所有的数字。现在你可以在控制台中输入 <code>app.data.str = &quot;新消息123&quot;</code>，看一下过滤器发挥的作用。</p><script src="../../../../js/Ale.v1.min.js"></script><script>Ale.filter(function(msg){    return msg.replace(/0/g, "").replace(/1/g, "").replace(/2/g, "").replace(/3/g, "").replace(/4/g, "").replace(/5/g, "").replace(/6/g, "").replace(/7/g, "").replace(/8/g, "").replace(/9/g, "");})Ale("com1", {    template: function(){        return this.data.str;    }});var app = Ale.render("com1", {    el: "#app",    data: {        str: "Hello World"    }})</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;过滤器&quot;&gt;&lt;a href=&quot;#过滤器&quot; class=&quot;headerlink&quot; title=&quot;过滤器&quot;&gt;&lt;/a&gt;过滤器&lt;/h1&gt;&lt;h3 id=&quot;filter-函数&quot;&gt;&lt;a href=&quot;#filter-函数&quot; class=&quot;headerlink&quot; title=&quot;fil
      
    
    </summary>
    
      <category term="v1" scheme="http://cn.alejs.org/categories/v1/"/>
    
    
  </entry>
  
  <entry>
    <title>配置</title>
    <link href="http://cn.alejs.org/guide/v1/config/"/>
    <id>http://cn.alejs.org/guide/v1/config/</id>
    <published>2018-12-19T11:25:50.770Z</published>
    <updated>2019-01-10T06:33:38.614Z</updated>
    
    <content type="html"><![CDATA[<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><h3 id="config-函数"><a href="#config-函数" class="headerlink" title="config 函数"></a>config 函数</h3><p>Ale 函数内置了 <code>Ale.config</code> 函数，用来更改一些 Ale 配置信息。目前 config 函数支持的配置如下：</p><ul><li>html <strong>（默认false）</strong>【数据若存在HTML标签输出则为节点（关闭此选项可以预防xss攻击，不要轻易打开）】</li><li>diff <strong>（默认true）</strong>【是否在操作 DOM 时应用 diff 算法（推荐小应用关闭，中大型应用需要开启）】</li><li>async <strong>（默认true）</strong>【是否启用异步 DOM（推荐开启）】<div class="v100-add"></div></li><li>configLock <strong>（默认false）</strong>【是否锁定配置信息（推荐修改完配置之后就打开）】<div class="v100-add"></div></li></ul><p>你可以通过如下方式更改某一种配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Ale.config(<span class="string">"html"</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 或 */</span></span><br><span class="line"></span><br><span class="line">Ale.config(&#123;</span><br><span class="line">    html: <span class="literal">true</span>,</span><br><span class="line">    diff: <span class="literal">false</span>,</span><br><span class="line">    <span class="keyword">async</span>: <span class="literal">false</span>,</span><br><span class="line">    configLock: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerlink&quot; title=&quot;配置&quot;&gt;&lt;/a&gt;配置&lt;/h1&gt;&lt;h3 id=&quot;config-函数&quot;&gt;&lt;a href=&quot;#config-函数&quot; class=&quot;headerlink&quot; title=&quot;config 
      
    
    </summary>
    
      <category term="v1" scheme="http://cn.alejs.org/categories/v1/"/>
    
    
  </entry>
  
  <entry>
    <title>组件基础</title>
    <link href="http://cn.alejs.org/guide/v1/ComponentFoundation/"/>
    <id>http://cn.alejs.org/guide/v1/ComponentFoundation/</id>
    <published>2018-12-19T09:59:24.053Z</published>
    <updated>2019-01-10T07:26:12.184Z</updated>
    
    <content type="html"><![CDATA[<h1 id="组件基础"><a href="#组件基础" class="headerlink" title="组件基础"></a>组件基础</h1><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><p>在介绍章节中，你已经学习了一些基础的定义和渲染组件的函数。这些基础将不会在本章中出现，如果你还没有学习过部分内容，请访问 <a href="/guide/v1/Introduction/">介绍</a> 页面。</p><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>在介绍页面，我们已经了解了关于 <strong>template</strong> 属性的一些知识：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个名为 com1 的组件</span></span><br><span class="line">Ale(<span class="string">"com1"</span>, &#123;</span><br><span class="line">    template: <span class="string">"HelloWorld"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>其实，<strong>template</strong> 属性还支持接收一个函数，但是具体的模板需要使用<code>return</code>返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个名为 com1 的组件</span></span><br><span class="line">Ale(<span class="string">"com1"</span>, &#123;</span><br><span class="line">    template: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"HelloWorld"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//当然，你也可以使用 ES6 语法来定义模板</span></span><br><span class="line">Ale(<span class="string">"com1"</span>, &#123;</span><br><span class="line">    template()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"HelloWorld"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>之后我们需要去渲染这个组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ale.render(<span class="string">"com1"</span>, &#123;</span><br><span class="line">    el: <span class="string">"#app"</span> <span class="comment">/* 目标元素选择器 */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p class="demo" id="app"></p><p>那么，将 <strong>template</strong> 属性设置为函数有什么好处呢？其实，它可以自动绑定一个叫 <code>data</code> 的属性。</p><p>例如我们在 <code>data</code> 属性里定义一个名为<code>name</code>的值，然后渲染它：<br><strong>【在1.0.0版本之前，使用this代指的实际是this.data，而1.0.0版本将this改为代指渲染完成后的 ale组件对象】<em>（如果你不知道这句话是什么意思，请先不用管它）</em></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Ale(<span class="string">"com1"</span>, &#123;</span><br><span class="line">    template: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + <span class="keyword">this</span>.data.name;</span><br><span class="line">    &#125;,</span><br><span class="line">    data: &#123;</span><br><span class="line">        name: <span class="string">"World"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 切记一定不可使用 ES6 的箭头函数，因为箭头函数不会绑定 this</span></span><br><span class="line"><span class="comment">Ale("com1", &#123;</span></span><br><span class="line"><span class="comment">    template: () =&gt; &#123;</span></span><br><span class="line"><span class="comment">        return "Hello " + this.data.name; //错误！</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    data: &#123;</span></span><br><span class="line"><span class="comment">        name: "World"</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p class="demo" id="app2"></p><h3 id="高级操作"><a href="#高级操作" class="headerlink" title="高级操作"></a>高级操作</h3><h4 id="Data"><a href="#Data" class="headerlink" title="Data"></a>Data</h4><p>你也可以在组件被渲染时动态设置 <code>data</code>。其中，重名的属性将会被重新赋值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Ale.render(<span class="string">"com1"</span>, &#123;</span><br><span class="line">    el: <span class="string">"#app"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        name: <span class="string">"Ale.js"</span> <span class="comment">/* 会被重新赋值为 Ale.js */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p class="demo" id="app3"></p><p>当然，同一个组件也可以被渲染多次：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Ale.render(<span class="string">"com1"</span>, &#123;</span><br><span class="line">    el: <span class="string">"#app"</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Ale.render(<span class="string">"com1"</span>, &#123;</span><br><span class="line">    el: <span class="string">"#app2"</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Ale.render(<span class="string">"com1"</span>, &#123;</span><br><span class="line">    el: <span class="string">"#app3"</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        name: <span class="string">"Ale.js"</span> <span class="comment">/* 也可以拥有不同的属性 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="局部组件"><a href="#局部组件" class="headerlink" title="局部组件"></a>局部组件<div class="v100-add"></div></h4><p>如果你在定义组件时未添加名称，那么 <code>Ale()</code> 函数将会返回给你一个 <code>Ale局部组件生成对象</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 定义一个变量来接收 Ale局部组件生成对象 */</span></span><br><span class="line"><span class="keyword">var</span> com = Ale(&#123;</span><br><span class="line">    template: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"HelloWorld"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>你可以使用 <code>Ale局部组件生成对象</code> 的 <code>render</code> 函数来渲染这个组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.render(&#123;</span><br><span class="line">    el: <span class="string">"#app"</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><script src="../../../../js/Ale.v1.min.js"></script><script>Ale("com1", {    template: function(){        return "HelloWorld";    }});Ale.render("com1", {    el: "#app"})Ale("com2", {    template: function(){        return "Hello "+this.data.name;    },    data: {        name: "World"    }});Ale.render("com2", {    el: "#app2"})Ale.render("com2", {    el: "#app3",    data: {        name: "Ale.js"    }})</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;组件基础&quot;&gt;&lt;a href=&quot;#组件基础&quot; class=&quot;headerlink&quot; title=&quot;组件基础&quot;&gt;&lt;/a&gt;组件基础&lt;/h1&gt;&lt;h3 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="v1" scheme="http://cn.alejs.org/categories/v1/"/>
    
    
  </entry>
  
  <entry>
    <title>安装</title>
    <link href="http://cn.alejs.org/guide/v1/Install/"/>
    <id>http://cn.alejs.org/guide/v1/Install/</id>
    <published>2018-12-18T12:21:52.127Z</published>
    <updated>2019-01-11T13:46:57.145Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h4 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h4><p>Ale 不支持 IE8 及以下版本，因为 Ale 使用了 IE8 无法模拟的 ECMAScript 5 特性。但它支持所有兼容 ECMAScript 5 的浏览器。</p><h4 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h4><p>最新稳定版本：<strong>1.0.0</strong></p><p>每个版本的更新日志见 <a href="https://github.com/Ale-js/ale/releases" target="_blank" rel="noopener">GitHub</a>。</p><h3 id="直接用-lt-script-gt-引入"><a href="#直接用-lt-script-gt-引入" class="headerlink" title="直接用 &lt;script&gt; 引入"></a>直接用 &lt;script&gt; 引入</h3><p>直接下载并用 <code>&lt;script&gt;</code> 标签引入，<code>Ale</code> 会被注册为一个全局变量。</p><p></p><p class="info-box">不要在生产版本下使用未经压缩的 <code>ale.js</code> 文件，否则这会降低你的文件加载速度！</p><p></p><p><strong>我们强烈推荐你使用码云 (Gitee) 下载：</strong> 【你也可以 <strong><span id="choose-version-btn" style="cursor: pointer; color: gray">切换至GITHUB</span></strong>】</p><p><br></p><p><a id="dev-download-btn" href="https://gitee.com/Ale-js/ale/tree/master/dist" target="_blank" rel="noopener"><button class="post-btn post-btn-red" style="margin-bottom: 15px">开发版本</button></a><br><a id="pro-download-btn" href="https://gitee.com/Ale-js/ale/releases" target="_blank" rel="noopener"><button class="post-btn post-btn-red">生产版本</button></a></p><h4 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h4><p>我们推荐链接到一个你可以手动更新的指定版本号：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/alejs@1.0.0-beta.1/ale.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>请确认了解不同构建版本并在你发布的站点中使用生产环境版本，把 <code>ale.js</code> 换成 <code>ale.min.js</code>。</p><h3 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h3><p>在用 Ale 构建大型应用时推荐使用 NPM 安装，因为 NPM 能很好地和诸如 webpack 或 browserify 这种的模块打包器配合使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 最新稳定版</span><br><span class="line"><span class="meta">$</span> npm i alejs</span><br></pre></td></tr></table></figure><script>var chooseBtnEl = document.querySelector("#choose-version-btn"),devBtnEl = document.querySelector("#dev-download-btn"),proBtnEl = document.querySelector("#pro-download-btn"),devInBtnEl = document.querySelector("#dev-download-btn button"),proInBtnEl = document.querySelector("#pro-download-btn button");chooseBtnEl.onclick = toGitee;function toGitee(){    chooseBtnEl.innerHTML = "切换至GITEE";    chooseBtnEl.style.color = "rgb(222, 11, 11)";    devBtnEl.setAttribute('href', 'https://github.com/Ale-js/ale/tree/master/dist');    devInBtnEl.setAttribute('class', 'post-btn post-btn-blue');    proBtnEl.setAttribute('href', 'https://github.com/Ale-js/ale/releases');    proInBtnEl.setAttribute('class', 'post-btn post-btn-blue');    chooseBtnEl.onclick = toGithub;}function toGithub(){    chooseBtnEl.innerHTML = "切换至GITHUB";    chooseBtnEl.style.color = "gray";    devBtnEl.setAttribute('href', 'https://gitee.com/Ale-js/ale/tree/master/dist');    devInBtnEl.setAttribute('class', 'post-btn post-btn-red');    proBtnEl.setAttribute('href', 'https://gitee.com/Ale-js/ale/releases');    proInBtnEl.setAttribute('class', 'post-btn post-btn-red');    chooseBtnEl.onclick = toGitee;}</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h1&gt;&lt;h4 id=&quot;兼容性&quot;&gt;&lt;a href=&quot;#兼容性&quot; class=&quot;headerlink&quot; title=&quot;兼容性&quot;&gt;&lt;/a&gt;兼容性&lt;/h4&gt;&lt;p
      
    
    </summary>
    
      <category term="v1" scheme="http://cn.alejs.org/categories/v1/"/>
    
    
  </entry>
  
  <entry>
    <title>对比其他框架</title>
    <link href="http://cn.alejs.org/guide/v1/Comparison/"/>
    <id>http://cn.alejs.org/guide/v1/Comparison/</id>
    <published>2018-12-18T12:14:50.113Z</published>
    <updated>2019-01-05T01:49:06.829Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对比其他框架"><a href="#对比其他框架" class="headerlink" title="对比其他框架"></a>对比其他框架</h1><p>欢迎来到这个页面，我们相信你来这里的目的就是为了解 Ale 与其他大型框架的区别，这也正是我们想要在此回答的。</p><p>客观来说，作为 Ale 的核心开发者，我们肯定会更偏爱 Ale，认为对于某些问题来讲用 Ale 解决会更好。但是在此，我们想尽可能地公平和准确地来描述一切。其他的框架也有显著的优点，例如 React 庞大的生态系统，或者像是 Angular 和 Vue 有着众多应对大型项目的解决方案。我们会尝试着把这些内容全部列出来。</p><p><br></p><p>我们也希望得到<strong>你</strong>的帮助，来使文档保持最新状态，因为 JavaScript 的世界进步的太快。如果你注意到一个不准确或似乎不太正确的地方，请提交问题让我们知道。</p><p><br></p><h3 id="React"><a href="#React" class="headerlink" title="React"></a>React</h3><p>React 和 Ale 几乎极其相似。事实上，React 就是初期 Ale 的灵感来源，它们都有：</p><ul><li>在状态（数据）更新时只更新必要的【使用 <strong>diff</strong> 算法】</li><li>提供了 <strong>响应式</strong> 和 <strong>组件化</strong> 的视图组件。</li><li>将注意力集中保持在核心库，而将其他功能交给相关的库。</li></ul><p>由于有着众多的相似处，我们会用更多的时间在这一块进行比较。这里我们不只保证技术内容的准确性，同时也兼顾了平衡的考量。我们需要承认 React 比 Ale 更好的地方，比如更丰富的生态系统。</p><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>这里我们仅针对 <strong>组件定义</strong> 和 <strong>组件渲染</strong> 做了测试，所以测试结果不能代表全部性能。但是可以确定的是，Ale 在这两个方面要胜过 React：（定义一次组件并渲染1000个元素）</p><ul><li>Ale: 46~52 (ms)</li><li>React: 307~336 (ms)</li></ul><p>当然，我们还做了关于响应式动态渲染的测试，结果展示 Ale 再执行动态渲染时比 React 要快 2.5 倍。</p><p>造成 React 的速度这么慢的原因，当然可能是因为我们用<code>Babel</code>进行动态渲染。但是不要忘记，Ale 并不需要编译，如果提前编译好 React，这对 Ale 就有一些不公平了。</p><h4 id="HTML-amp-CSS"><a href="#HTML-amp-CSS" class="headerlink" title="HTML &amp; CSS"></a>HTML &amp; CSS</h4><p>在 React 中，一切都是 JavaScript。不仅仅是 HTML 可以用 JSX 来表达，现在的潮流也越来越多地将 CSS 也纳入到 JavaScript 中来处理。这类方案有其优点，但也存在一些不是每个开发者都能接受的取舍。</p><p>Ale 的整体思想是拥抱经典的 Web 技术，并在其上进行扩展。我们下面会详细分析一下。</p><h5 id="JSX-vs-Templates"><a href="#JSX-vs-Templates" class="headerlink" title="JSX vs Templates"></a>JSX vs Templates</h5><p>在 React 中，所有的组件的渲染功能都依靠 JSX。JSX 是使用 XML 语法编写 JavaScript 的一种语法糖。</p><p>使用 JSX 具有下面这些优势：</p><ul><li>你可以使用完整的编程语言 JavaScript 功能来构建你的视图页面。比如你可以使用临时变量、JS 自带的流程控制、以及直接引用当前 JS 作用域中的值等等。</li><li>开发工具对 JSX 的支持相比于现有可用的其他 Ale 模板还是比较先进的 (比如，linting、类型检查、编辑器的自动完成)。</li></ul><p>但是事实上，Ale 也提供了渲染函数，甚至 Ale 抛弃了传统的 Mustache(JSX) 模板，选择了不是那么普及的渲染函数，这其中包括以下几个方面：</p><ul><li>依赖于 JavaScript 自身完整的编译器，使得我们不再需要手动编写模板渲染函数，这样做可以有效提高 Ale 模板编译的整体速度，因为渲染函数比模板引擎更加接近 JavaScript 编译器本身。</li><li>当你在 JSX 模板里添加 JavaScript 表达式时，一些编译器并没有相应的语法提示。同时，在一些场景中，你真的需要 JavaScript 完全编程的能力。</li></ul><h4 id="规模"><a href="#规模" class="headerlink" title="规模"></a>规模</h4><h5 id="向上扩展"><a href="#向上扩展" class="headerlink" title="向上扩展"></a>向上扩展</h5><p>好吧，说句实话，Ale 真的不是针对大型应用设计的，我们设计它的初衷就是希望它能够处理几乎全部的中小型应用需求。</p><p>相比之下，React 提供了强大的路由来应对大型应用。并且 React 社区在状态管理方面非常有创新精神 (比如 Flux、Redux)，这一点是 Ale 所不能比拟的。</p><h5 id="向下扩展"><a href="#向下扩展" class="headerlink" title="向下扩展"></a>向下扩展</h5><p>React 学习曲线陡峭，在你开始学 React 前，你需要知道 JSX 和 ES2015，因为许多示例用的是这些语法。你需要学习构建系统，虽然你在技术上可以用 Babel 来实时编译代码，但是这并不推荐用于生产环境。</p><p>不过 Ale 向下扩展后就极其类似于 jQuery。因为你只要把如下标签放到页面就可以运行：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"ale.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后你就可以编写 Ale 代码并应用到生产中，你只要用 min 版 Ale 文件替换掉就不用担心其他的性能问题。</p><p>由于 Ale 的起步阶段不需学习任何复杂的知识点，比如 ES2015 以及 JSX，所以开发者只需不到半小时的时间阅读指南就可以立即建立简单的应用程序。</p><h4 id="原生渲染"><a href="#原生渲染" class="headerlink" title="原生渲染"></a>原生渲染</h4><p>React Native 能使你用相同的组件模型编写有本地渲染能力的 APP (iOS 和 Android)。能同时跨多平台开发，对开发者是非常棒的。相比之下，Ale 在这方面就显得薄弱一些。但是我们并没有就此收手，随着 Ale 慢慢发展起来，这些构建系统会相应发布，敬请期待。</p><h4 id="体积"><a href="#体积" class="headerlink" title="体积"></a>体积</h4><p>和 React 相比，Ale 显得极其轻量，Ale的压缩文件（非g-zip）【包含操作DOM的API】只有大约 <strong>8kb</strong> 大小，而 React 的核心库加 DOM 库则有着惊人的 <strong>108kb</strong>。</p><h4 id="Preact-和其它类-React-库"><a href="#Preact-和其它类-React-库" class="headerlink" title="Preact 和其它类 React 库"></a>Preact 和其它类 React 库</h4><p>类 React 的库们往往尽可能地与 React 共享 API 和生态。因此上述比较对它们来说也同样适用。它们和 React 的不同往往在于更小的生态和更高的性能。但是因为这些库无法 100% 兼容 React 生态中的全部，所以部分工具和辅助库可能无法使用。或者即使看上去能工作，但也有可能随时发生不兼容，除非你用的这个类 React 库官方与 React 保持严格一致。</p><h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><p>到了对比最重要框架的时候了。之前我们说过 React 是早期 Ale 的灵感来源。事实上，Ale 的更多灵感来源于 Vue，这也是为什么 Ale 提供的部分特性和 API 都极其类似 Vue。</p><p>不过，尽管 Ale 与 Vue 在某些地方有相似之处，但是我们还是推荐你同时安装 Ale 和 Vue，因为 Vue 可以使 Ale 的开发变得更加高效。不过如果你不想这么做，也可以只安装一个框架。</p><h4 id="复杂性"><a href="#复杂性" class="headerlink" title="复杂性"></a>复杂性</h4><p>在 API 与设计两方面上 Ale.js 都比 Vue 简单得多，并且更加适合初学者学习，因此你可以快速地掌握它的全部特性并投入开发。</p><h4 id="灵活性和组件化"><a href="#灵活性和组件化" class="headerlink" title="灵活性和组件化"></a>灵活性和组件化</h4><p>与 Angular 相比之下，Vue.js 是一个更加灵活开放的解决方案。但是在 Ale 中，这种情况将会发生改变。</p><p>事实上，Vue 在不同组件间强制使用单向数据流，这使应用中的数据流更加清晰易懂，但是同时也限制了组件之间的灵活操作。在 Ale 中，只存在复合组件，并不存在父子组件，而复合组件中的任何组件都可以互相操作，因为它们共用一套数据。</p><h4 id="性能-1"><a href="#性能-1" class="headerlink" title="性能"></a>性能</h4><p>这里我们和 React 一样，也仅针对 <strong>组件定义</strong> 和 <strong>组件渲染</strong> 做了测试，所以测试结果不能代表全部操作的性能。但是可以确定的是，Ale 在这两个方面要胜过 Vue：（定义一次组件并渲染1000个元素）</p><ul><li>Ale: 46~52 (ms)</li><li>Vue: 181~228 (ms)</li></ul><h4 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h4><p>Vue 为 TS 提供了官方的 类型声明 和 组件装饰器，但并不是所有人都想用 TS。在中小型规模的项目中，引入 TS 可能并不会带来太多明显的优势。在这些情况下，用 Ale 会是更好的选择。</p><h4 id="体积-1"><a href="#体积-1" class="headerlink" title="体积"></a>体积</h4><p>单独的 vue.min.js 文件体积有 <strong>88kb</strong> 大小，而 Ale 仅有大约 <strong>8kb</strong> 大小，相比 Vue 来说还算是比较轻量的。</p><h4 id="学习曲线"><a href="#学习曲线" class="headerlink" title="学习曲线"></a>学习曲线</h4><p>就这点来说，两个框架都差不多，无非就是需要你具有良好的 HTML 和 JavaScript 基础。有了这些基本的技能，你就可以非常快速地通过阅读指南投入开发。</p><p>但是具体来说，Vue 的 API 面积比起 Ale 要大得多，你也因此需要理解更多的概念才能开始有效率地工作。当然，Vue 本身的复杂度是因为它的设计目标就是针对大型的复杂应用。但不可否认的是，这也使得它对于经验不甚丰富的开发者相当的不友好。</p><h3 id="Angular"><a href="#Angular" class="headerlink" title="Angular"></a>Angular</h3><p>当然，编者对于 Angular 的了解并不是很多，所以并不能很好地做出对比。在此，我们希望更多有经验的开发者能够帮助我们撰写对比 Angular 的文章，具体你可以点击下方 <strong>编辑页面</strong>，然后前往 Github 做出提交，感谢你的支持与理解！</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>其实之前在性能方面还有一点需要补充，因为 Vue 和 React 采用虚拟 DOM 和 diff 算法。而 Ale 实际上是直接遍历真实 DOM 树，然后采用 diff 算法对比差异，这一点类似于 Angular 的脏检查，性能会受到一些影响。不过，这种方式也免除了需要创建虚拟 DOM 树的麻烦。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;对比其他框架&quot;&gt;&lt;a href=&quot;#对比其他框架&quot; class=&quot;headerlink&quot; title=&quot;对比其他框架&quot;&gt;&lt;/a&gt;对比其他框架&lt;/h1&gt;&lt;p&gt;欢迎来到这个页面，我们相信你来这里的目的就是为了解 Ale 与其他大型框架的区别，这也正是我们想要在此回答的
      
    
    </summary>
    
      <category term="v1" scheme="http://cn.alejs.org/categories/v1/"/>
    
    
  </entry>
  
</feed>
